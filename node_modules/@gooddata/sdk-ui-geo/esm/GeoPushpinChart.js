import { __assign, __spreadArrays } from "tslib";
// (C) 2019-2022 GoodData Corporation
import React from "react";
import compact from "lodash/compact";
import omit from "lodash/omit";
import { CoreGeoChart } from "./core/CoreGeoChart";
import { BucketNames, IntlTranslationsProvider, IntlWrapper, withContexts, useResolveValuesWithPlaceholders, } from "@gooddata/sdk-ui";
import { bucketsAttributes, bucketsMeasures, disableComputeRatio, MeasureGroupIdentifier, newBucket, newDimension, } from "@gooddata/sdk-model";
import { withTheme } from "@gooddata/sdk-ui-theme-provider";
var getBuckets = function (props) {
    var color = props.color, location = props.location, segmentBy = props.segmentBy, size = props.size, config = props.config;
    var buckets = [
        newBucket.apply(void 0, __spreadArrays([BucketNames.SIZE], (size ? [disableComputeRatio(size)] : []))),
        newBucket.apply(void 0, __spreadArrays([BucketNames.COLOR], (color ? [disableComputeRatio(color)] : []))),
        newBucket.apply(void 0, __spreadArrays([BucketNames.LOCATION], (location ? [location] : []))),
        newBucket.apply(void 0, __spreadArrays([BucketNames.SEGMENT], (segmentBy ? [segmentBy] : []))),
    ];
    var tooltipText = config === null || config === void 0 ? void 0 : config[BucketNames.TOOLTIP_TEXT];
    if (tooltipText) {
        buckets.push(newBucket(BucketNames.TOOLTIP_TEXT, tooltipText));
    }
    return buckets;
};
/**
 * @internal
 */
export function getGeoChartDimensions(def) {
    var buckets = def.buckets;
    var measures = bucketsMeasures(buckets);
    var attributes = bucketsAttributes(buckets);
    return compact([measures.length > 0 && newDimension([MeasureGroupIdentifier]), newDimension(attributes)]);
}
/**
 * Specifies props that are on geo chart props but not on core chart props - these must not be passed
 * down to core chart.
 */
var NON_CORE_PROPS = [
    "backend",
    "workspace",
    "segmentBy",
    "filters",
    "sortBy",
    "location",
    "color",
    "size",
];
function GeoPushpinChartInner(props) {
    var _a;
    var backend = props.backend, workspace = props.workspace, sortBy = props.sortBy, filters = props.filters, exportTitle = props.exportTitle, _b = props.execConfig, execConfig = _b === void 0 ? {} : _b;
    var buckets = getBuckets(props);
    var newProps = omit(props, NON_CORE_PROPS);
    var execution = (_a = backend
        .withTelemetry("GeoPushpinChart", props)
        .workspace(workspace)
        .execution()
        .forBuckets(buckets, filters))
        .withSorting.apply(_a, (sortBy || [])).withDimensions(getGeoChartDimensions)
        .withExecConfig(execConfig);
    return (React.createElement(IntlWrapper, { locale: props.locale },
        React.createElement(IntlTranslationsProvider, null, function (translationProps) {
            return (React.createElement(CoreGeoChart, __assign({ intl: translationProps.intl, execution: execution, exportTitle: exportTitle || "GeoPushpinChart" }, newProps)));
        })));
}
var WrappedGeoPushpinChart = withTheme(withContexts(GeoPushpinChartInner));
/**
 * @public
 */
export var GeoPushpinChart = function (props) {
    var _a = useResolveValuesWithPlaceholders([props.location, props.size, props.color, props.segmentBy, props.filters, props.sortBy], props.placeholdersResolutionContext), location = _a[0], size = _a[1], color = _a[2], segmentBy = _a[3], filters = _a[4], sortBy = _a[5];
    return React.createElement(WrappedGeoPushpinChart, __assign({}, props, { location: location, size: size, color: color, segmentBy: segmentBy, filters: filters, sortBy: sortBy }));
};
//# sourceMappingURL=GeoPushpinChart.js.map